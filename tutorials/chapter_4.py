# 빅오, 자료형

# 자료형
# 파이썬 자료형 

# None : class None Type

# 숫자 
# - 정수형 : 정수(class int), 불리언(class bool)
# - 실수형(class float)

# 집합형
# - 집합(class set)

# 매핑
# - 딕셔너리(class dict)

# 시퀀스
# - 불변 : 문자열(class str), 튜플(class tuple), 바이트(class bytes)
# - 가변 : 리스트(class lit)


# 숫자
# 파이썬에서는 숫자 정수형으로 int만을 제공
# int보다 더 큰 값은 어떤 자료형에 보관? 
# 원래 파이썬은 ver2 까지 int와 long을 별도로 제공
# int는 C 스타일의 고정 정밀도(fixed-precision) 정수형이었고
# long은 임의 정밀도(arbitraray-precision)이었다
# 2.4 부터는 int가 충분하지 않으면 자동으로 long 타입으로 변경되는 구조가 됨
# C와 달리 overflow가 발생하는 일이 사라짐
# ver3 부터는 아예 int 단일형으로 통합
# int는 임의 정밀도를 지원, 더이상 파이썬에서 고정 정밀도 정수형은 지원 X

# BOOL은 엄밀히 따지자면 논리형 자료형, 파이썬에서는 내부적으로 1(True), 0(False)으로 처리되는
# int의 usb class이다
# int는 object의 하위 클래스이기도 하기 때문에 결국 다음과 같은 구조를 띤다

# object > int > bool

# 논리 자료형의 값인 True와 정수형의 값인 1을 비교해보면 다음과 같다
print(True==1) # True
print(False==0) # True

# 비교연산자 == 을 통해 확인한 결과, 논리 자료형은 내부적으로 정수값을 가지고 있음을 확인할 수 있다

# 매핑
# 매핑 Mappping 타입은 키와 자료형으로 구성된 복합 자료형
# 파이썬에서 내장된 유일한 매핑 자료형은 딕셔너리


# 집합
# 파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형
# 파이썬에서 빈 집합은 다음과 같은 형태로 선언
a = set()
print(a) # set()
print(type(a)) # <class 'set'>

# 빈 집합이 아닌 값이 포함된 집합을 선언할 때는 a = {1, 2, 3} 형태로 하는데
# 집합은 딕셔너리와 동일하게 중괄호 {}를 사용하므로 유의
# 구분하는 방법?
# 딕셔너리는 key, value 형태이지만 집합은 value, 값만 선언하므로 선언 형태를 보면 타입 판단 가능
# 파이썬 컴파일러는 타입 결정을 자동으로 한다

a = {'a', 'b', 'c'}
print(type(a)) # <class 'set'>

a = {'a': 'A', 'b': 'B', 'c' : 'C'}
print(type(a)) # <class 'dict'>

# set은 입력 순서가 유지되지 않으며!!! 다음처럼 중복된 값이 있을 경우 하나의 값만 유지한다
a = {3, 2, 3, 5}
print(a) # {2, 3, 5}


# 시퀀스
# 시퀀스 Sequence는 우리 말로 하면 '수열'과 같은 의미
# 어떤 특정 대상의 순서 있는 나열! 을 뜻한다
# 예를 들어 str은 문자의 순서 있는 나열로 문자열로 이루는 자료형,
# list는 다양한 값들을 배열 형태의 순서 있는 나열로 구성하는 자료형
# 파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행한다
# 시퀀스는 불변 immutable과 가변 mutable로 구분하는데, 말 그대로 불변은 값을 변경할 수 없다
# 여기에는 str, tuple, bytes 가 해당되는데 한 번 이 타입으로 선언되는 값은 변경할 수 없다
# str 변수는 값을 변경할 수 있는데? 라는 의문이 든다면 다음을 살펴보자

a = 'abc' 
a= 'def'
print(type(a)) # <class 'str'>

# a 변수는 str 자료형인데 처음에 abc를 할당했다가 이후엔 def를 할당함
# a 변수의 값이 변경된 셈
# 그런데, str은 값이 변경되지 않는 불변이라는 것은 무슨 의미?
# 맨 처음에 a 변수에 할당된 str 타입인 'abc'는 변경된 적이 없다, 불변이다!
# 이후에 a 변수는 다른 str타입인 def를 다시 참조했을 뿐
# 실제로 abc도 def도 한 번 생성된 후에 변경된 적이 없다
# 불변이므로 변경될 수도 없다
# ???

a = 'abc'
print(id('abc')) # 1777437741360
print(id(a)) # 1777437741360
a = 'def'
print(id('def')) # 1777440145648
print(id(a)) # 1777440145648

# 각각의 메모리 주소를 출력해보면(id를 통해) a 변수는 처음에는 abc를 참조했다가(같은 주소)
# 이후에는 def를 참조하도록(같은 주소) 변경되었을 뿐이다
# abc와 def는 생성된 후에 변하지 않고 메모리 어딘가에 남아 있다


# str은 변경할 수 없으며, 불변이다 

# 반면 list는 가변이다
# 이 말은 리스트는 자유롭게 값을 추가, 삭제할 수 있는 동적 배열이다


# 각 언어별 자료형의 특징
# 언어 - 지원타입 형태
# C - 원시 타입
# Java - 원시 타입, 객체
# Python - 객체


# 객체
# 파이썬은 모든 것이 객체이다
# 이 중에서 크게 불변 객체 immutable object, 가변 객체 mutable object로 구분할 수 있다

# 불변 객체 : bool, int, float, tuple, str
# 가변 객체 : list, set, dict

# 불변 객체
# 무엇보다 파이썬은 모든 것이 객체이다
# 파이썬에서 변수를 할당하는 작업은 해당 객체에 대해 참조를 한다는 의미이다
# 여기에는 예외가 없으며 심지어 문자, 숫자도 모두 객체이다
# 다만, 문자와 숫자는 불변 객체라는 차이만 있을 뿐이다

10
a = 10
b = a

print(id(10)) # 140706626708144
print(id(a)) # 140706626708144
print(id(b)) # 140706626708144

# 10이라는 숫자가 있다
# 10을 a 변수에 할당했다
# 그리고 b 변수는 a 변수를 할당했다
# 만약 모두 원시 타입이라면 각각의 값들은 각 메모리의 다른 영역에 위치할 것
# 그러나 파이썬은 모든 것이 객체이므로
# 메모리 상에 위치한 객체의 주소를 얻어오는 id() 함수를 실행한 결과는 모두 동일
# 만약 10이 11이 된다면 a 변수와 b 변수 모두 값이 11로 바뀌게 될 것
# 그러나 그런 일은 일어나지 않는다, 숫자와 문자는 모두 불변 객체이기 때문이다
# 값을 담고 있는 변수는 사실은 참조일 뿐이고 실제로 값을 갖고 있는 int와 st은 모두 불변 객체이다
# 이외에도 불변 객체로 tuple이 있다
# 말 그대로 한번 값을 담아놓으면 더 이상 값을 변경할 수 없다
# 상수처럼 read-only 용도로 사용하거나 무엇보다 값이 변하지 않기 때문에
# dict의 key나 set의 값으로 사용할 수도 있다
# list는 언제든 값이 변할 수 있기 때문에 dict의 키로 정하거나 set의 값으로는 추가할 수 없다

# 가변 객체
# int, str과 달리 lsit는 값이 바뀔 수 있으며
# 이 말은 다른 변수가 참조하고 있을 떄 그 변수의 값 또한 변경된다는 이야기

a = [1, 2, 3, 4, 5]
b = a
print(b) # [1, 2, 3, 4, 5]
a[2] = 4
print(a) # [1, 2, 4, 4, 5]
print(b) # [1, 2, 4, 4, 5]

# 변수 a는 리스트이다
# b에는 a를 할당하여 참조가 되게 했다
# 이제 lsit인 a의 요소 하나를 조작해서 값을 변경했다
# 그렇다면 b의 값은?
# 그에 따라 b의 값도 변경 됐다
# 만약 b가 int나 str을 참조하고 있다면 불변 객체이기 때문에 이런 일이 절대 일어나지 않음
# lsit는 가변 객체이기 때문에 얼마든지 일어날 수 있다



# 문법
# is와 ==
# 파이썬의 비교 연산자 중 is와 ==이 있다
# 이 둘의 관계는 파이썬의 객체 구조와 관련이 깊다
# 먼저, is는 id() 값을 비교하는 함수이다
# None은 널(null)로서 값 자체가 정의되어 있지 않으므로 ==로 비교가 불가능하다
# 따라서 다음과 같이 is로만 비교가 가능하다

if a is None:
    pass

# ==는 값을 비교하는 연산자, 다음과 같이 리스트를 생성해서 비교해보면 ==와 is의 차이점을 이해할 수 있다

a = [1, 2, 3]
print(a==a) # True
print()
print(a==list(a)) # True
print()
print(a is a) # True
print()
print(a is list(a)) # False
print()

# 값은 동일하지만 list()로 한 번 더 묶어주면 별도의 객체로 복사가 되고, 다른 ID를 갖게 된다
# 따라서 is는 False가 된다
import copy
a = [1, 2, 3]
print(a == copy.deepcopy(a)) # True
print()
print(a is copy.deepcopy(a)) # False

# copy.deepcopy()로 복사한 결과 , 값은 같지만 ID는 다르기 때문에 
# ==으로 비교하면 True, is로 비교할 경우 False가 된다

# 참고
# 자료구조, 자료형, 추상 자료형
# 자료구조 Data Structure
# 자료형 Data Type
# 추상 자료형 Abstract Data Type 
# 각각의 정의 명확히 구분!
# 컴퓨터과학엥서 자료구조란 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조를 말한다
# 일반적으로 이야기하는 학문으로서의 자료구조를 일컫는다
# 보통 자료형과 자료구조를 많이 혼동하는데
# 자료형이란 컴파일러 또는 인터프리터에게 프로그래머가 데이터를 
# 어떻게 사용할지를 알려주는 일조의 데이터 속성 attribute 이다
# 좀 더 쉽게 말하자면 자료형은 자료구조에 비해 훨씬 더 구체적이며
# 특정 언어에서 자료형이라 함은 정수(integer), 실수(floating-point number), 문자열(string) 등
# 해당 언어에서 지원하는 원시 자료형까지 포함하는 모든 자료의 유형을 말한다

# 자료구조는 일반적으로 원시 자료형을 기반으로 하는 배열, 연결 리스트, 객체(object) 등을 말하며
# 자료형의 관점에서 보자면 여러 원시 자료형을 조합한 자료구조는 복합 자료형이 된다

# 마지막으로 추상자료형은 일반적으로 ADT라고 줄여 부르는데 자료형에 대한 수학적 모델을 지칭한다
# 좀 더 쉽게 정리하면, ADT란 해당 유형의 자료에 대한 연산들을 명기한 것
# ADT는 행동만을 정의할 뿐, 실제 구현 방법은 명시하지 않는다
# 이런 점에서 자료구조와는 다르다
# 객체 지향프로그래밍(OOP)에 경험이 있다면, '추상화 abstraction'을 떠올리면 이해하기 쉬울 것
# 추상화는 필수적인 속성만 보여주고 불필요한 정보는 감추는 것을 의미하는데
# 이처럼 인터페이스만 보여주고 실제 구현은 보여주지 않는다는 점에서
# ADT는 OOP의 추상화와 비슷한 개념이라 할 수 있다
