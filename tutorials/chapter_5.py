# 5장, 리스트와 딕셔너리

# 리스트와 딕셔너리는 파이썬을 사용하면서 가장 빈번하게 접하게 되는 자료형
# 특히 코딩 테스트에서 2가지 자료형은 거의 모든 문제에 빠짐ㅇ벗이 쓰이는 자료형!
# 구조를 확실히 이해해 기초를 튼튼히 하고 활용ㅂ버을 충분히 숙지해 문제 풀이에 자유자재로 활용할 수 있어야 한다
# 구조, 원리, 문법 자세히 공부!

# 리스트
# 파이썬의 list는 말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 목록 mutable list!
# 입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다
# 동적 배열의 구조에 대해서는 7장에서 자세히

# 각 언어별 동적 배열 구현
# 언어 - 동적 배열
# Python - list()
# C++ - std::vector
# Java - ArrayList

# 파이썬뿐만 아니라 현대 언어들은 언어별로 대부분 동적 배열을 지원하며 
# C++, Java에서도 동적 배열은 가장 자주 쓰이는 자료형 중 하나

# 파이썬 리스트의 가장 좋은 점 : 매우 다양한 기능 제공
# 리스트를 사용하면 사실상 스택을 사용할지, 큐를 사용할지를 고민하지 않아도 된다
# 스택과 큐에서 사용 가능한 모든 연산을 함께 제공
# 리스트는 다양한 기능을 제공하면서도 O(1)에 실행 가능한 연산들도 몇 가지 있다
# 리스트 마지막에 요소를 .append()로 추가하거나
# 리스트 마지막 요소를 pop()으로 추출하거나
# 원하는 인덱스의 요소를 조회(원래 배열이므로 당연하다)하는 연산은 모두 O(1)이다
# 반면 요소를 삭제하거나 큐의 연산이기도 한 첫 번째 요소를 추출하는 pop(0)은 O(n)이다
# 따라서 리스트에서 주로 큐의 연산을 사용할 때는 주의가 필요
# 이 경우 데크 Deque 같은 자료형으로 성능을 높일 수 있는데 이는 9장에서 다룸

# 리스트의 주요 연산 시간 복잡도

# 연산 - 시간 복잡도 : 설명
# len(a) - O(1) : 전체 요소의 개수를 리턴
# a[i] - O(1) : 인덱스 i의 요소를 가져온다
# a[i:j] - O(k) : i부터 j까지 슬라이스의 길이만큼 k개의 요소를 가져온다, 
#                 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)
# elem in a - O(n) : elem 요소가 존재하는지 확인, 처음부터 순차 탐색하므로 n만큼 시간이 소요
# a.count(elem) - O(n) : elem 요소의 개수를 리턴
# a.index(elem) - O(n) : elem 요소의 인덱스를 리턴
# a.append(elem) - O(1) : 리스트 마지막에 elem 요소 추가
# a.pop() - O(1) : 리스트 마지막 요소를 추출, stack의 연산이다
# a.pop(0) - O(n) : 리스트 첫 번째 요소를 추출, 큐의 연산, 이 경우 전체 복사가 필요하므로 O(n)이다, 
#                   큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장함
# del a[i] - O(n) : i에 따라 다르다, 최악의 경우 O(n)
# a.sort() - O(n log n) : 정렬한다, 팀소트(Timsort)를 사용하며 최선의 경우 O(n)에도 실행될 수 있다
# min(a), max(a) - O(n) : 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다
# a.reverse() - O(n) : 뒤집는다, 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다

# 리스트의 경우 탐색 시 값의 존재 유무를 확인하려면 정렬된 경우에는 이진 검색이 효율적
# 그러나 매번 정렬이 필요하고 대개는 리스트가 정렬된 상태가 아니기 때문에
# 리스트의 경우에는 모든 element를 순차적으로 조회하는 형태로 구현되어 있다
# 이 경우 최악의 경우 항상 O(n)이 소요된다

# 리스트의 활용 방법
# 리스트는 다음과 같이 선언한다
# a = lsit()
# 또는 대괄호로 더 간단히 선언
# a = []

# 다음과 같이 초깃값을 지정해 선언하거나 append()로 추가할 수 있다
a = [1, 2, 3] 
print(a) # [1, 2, 3]
a.append(4)
print(a) # [1, 2, 3, 4]

# insert() 함수를 사용하면 특정 위치의 인덱스를 지정해 요소를 추가 할 수 있다
# 다음과 같이 3번째 인덱스에 5를 삽입
a.insert(3, 5)
print(a) # [1, 2, 3, 5, 4]

# 파이썬의 리스트는 숫자 이외에도 다양한 자료형을 단일 리스트에 관리할 수 있어 매우 편리
a.append('안녕')
a.append(True)
print(a) # [1, 2, 3, 5, 4, '안녕', True]

# 다른 언어들은 동적 배열에 삽입할 수 있는 자료형을 동일한 타입으로 제한하는 경우가 많음
# 파이썬은 자유롭게 삽입 가능
# 이 경우 다른 언어들은 타입을 변환한다든지 등의 별도의 부가 처리를 해 줘야 하지만
# 파이썬은 이런 부분에 신경쓰지 않고 유연하게 활용할 수 있어 매우 편리
# 생산성 또한 매우 높다
# 값을 꺼내올 때는 간단히 인덱스를 지정하면 됨
print(a[3]) # 5

# 파이썬 리스트에는 슬라이싱 slicing 기능이 있어 특정 범위 내의 값을 매우 편리하게 가져올 수 있다
# 슬라이싱은 문자열에 유용하게 활용되는 기능, 리스트에도 동일한 형태로 유용하게 활용
# 슬라이싱은 간결, 강력함을 자랑, 파이썬의 특징을 잘 나타내는 대표적 기능 중 하나, 돋보이는 장점!
print(a[1:3]) # 2, 3

# 다른 언어들은 인덱스의 반복문을 구성하고 순회하면서 값을 출력해야 하는데, 
# 파이썬의 슬라이싱은 이처럼 시작 인덱스와 종료 인덱스를 설정해 간단히 해당하는 값을 출력 할 수 있다
# 시작 인덱스는 생략도 가능, 이 경우 처음부터 값을 가져옴
print(a[:3]) # 1, 2, 3

# 종료 인덱스 생략도 가능
print(a[4:]) # [4, '안녕', True]

# 다음과 같이 홀수 번째 인덱스의 값만 가져올 수도 있다
# index 1, 2, 3의 값
print(a[1:4]) # [2, 3, 5]
# index 1, 3의 값
print(a[1:4:2]) # [2, 5]

# 원래 1:4는 인덱스 1, 2, 3의 값을 가져오는데 세 번째 파라미터를 부여하면(2), 
# 단계 step의 의미로, 1:4:2의 경우 2칸씩 건너뛰게 된다
# idnex 1부터 시작해서 1에서 두 칸 건너뛴 3까지의 값을 가져온다
# 존재하지 않는 index를 조회할 경우 IndexError 발생

# print(a[9]) # IndexError: list index out of range

# IndexError는 인덱스가 리스트의 길이를 넘어설 때 발생, try 구문으로 에러에 대한 예외 처리를 할 수 있다
# try:
#     print(a[9])
# except IndexError:
#     print('list index out of range')
# list index out of range

# 만약 일단 시도를 하고, 어떠한 오류 메세지인 줄 모를 때, 진행은 시키고 그 오류메세지를 확인하고 싶을 때
# 다음의 코드를 사용하면 된다
import traceback

try:
    print(a[9])
except : 
    traceback.print_exc()

print('완료')

'''
Traceback (most recent call last):
  File "d:\leetcode\tutorials\chapter_5.py", line 122, in <module>
    print(a[9])
IndexError: list index out of range
완료
'''

# 리스트에서 요소를 삭제하는 방법은 크게 2가지로 나뉜다
# - 인덱스로 삭제하기
# - 값으로 삭제하기

# del 키워드를 사용하면 인덱스의 위치에 있는 요소를 삭제할 수 있다
print(a) # [1, 2, 3, 5, 4, '안녕', True]
del a[1]
print(a) # [1, 3, 5, 4, '안녕', True]

# remove() 함수를 사용하면 값에 해당하는 요소를 삭제할 수 있다
a.remove(3)
print(a) # [1, 5, 4, '안녕', True]

# 또는 pop() 함수를 사용하면 stack의 pop 연산처럼 추출로 처리도니다
# 삭제될 값을 리턴하고 삭제가 진행된다
print(a) # [1, 5, 4, '안녕', True]
print(a.pop(3)) # 안녕
print(a) # [1, 5, 4, True]

# 리스트의 특징
# 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과, 
# 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태!
# 실제로 리스트를 잘 사용하기만 해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력
# 때문에 파이썬은 아예 원시 타입 자료형은 제공하지도 않는다

# 다음은 CPython에서 리스트를 정의한 헤더 파일의 일부
'''
// cpython/Include/cpython/listopject.h
typerdef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
'''

# Cpython에서 리스트는 요소에 대한 포인터 목록(ob_item)을 가지고 있는 구조체로 선언되어 있다
# 리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현
# 파이썬의 모든 잘형은 정수형 또는 원시 타입이 아닌 객체로 되어 있음
# 리스트는 이처럼 객체로 되어 있는 모든 자료형을 포인터로 연결한다
# 파이썬은 모든 것이 객체며, 파이썬의 리스트는 이들 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다
# 사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있으며
# 그 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능을 자랑

# 다음은 정수로 이뤄진 값들을 파이썬 리스트에 삽입하는 코드
a = [1, 2, 3]
print(a) # [1, 2, 3]
# 일반적으로 정수형 배열이라고 하면 이처럼 정수로만 이뤄진 값을 연속된 메모리 공간에 저장하는 경우를 말함
# 정수가 아닌 값은 저장할 수 없음
# 그러나, 파이썬의 리스트는 연결 리스트에 대한 포인터 목록을 관리하고 있기 때문에
# 리스트의 활용 방법에서 살펴본 것처럼 정수, 문자, 불리언 등 제각기 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다
a = [1, '안녕', True]
print(a) # [1, '안녕', True]
# 이처럼 정수1, 문자'안녕', 불리언True 모두 제각각인 자료형을 a라는 단일 리스트에 모두 통합해서 저장할 수 있다
# 이러한 특징은 매우 강력하며 매우 편리하게 활용할 수 있다
# 그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능
# 결국 각각의 객체에 대한 참조로 구현할 수 밖에 없다
# 당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고 값을 일일이 살펴봐야하는 등
# 추가적인 작업이 필요하기 때문에, 속도 면에서도 훨씬 더 불리
# 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며, 이로 인해 부득이하게 속도를 희생한 측면이 있다



# 딕셔너리 Dictionary
# 파이썬의 딕셔너리는 key/value 구조로 이뤄진 딕셔너리를 말한다
# 파이썬 3.7+에서는 입력 순서가 유지되며, 내부적으로는 Hash Table 해시 테이블로 구현되어 있다
# 해시 테이블에 대해서는 11장에서 자세히
# 이외에 각 언어별 해시 테이블을 이용한 key/value 구조의 자료형은 다음과 같다
# 각 언어별 해시 테이블 구현
# 언어 - 해시 테이블
# Python - dict{}
# C++ - std::unordered_map
# Java - HashMap

# index를 숫자로만 지정할 수 있는 list와 달리 dictionary는 문자를 포함해 다양한 타입을 키로 사용할 수 있다
# 특히 파이썬의 딕셔너리는 해시할 수만 있으면 숫자뿐만 아니라 
# 문자, 집ㅎ바까지 불변 객체를 모두 키로 사용할 수 있다
# 이 과정을 해싱 Hashing 이라고 하며, 해시 테이블을 이용해 자료를 저장한다
# 무엇보다 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능
# 물론 최악의 경우 O(n)이 될 수도 있으나, 대부분은 빨리 실행 됨
# 분할 상환 분석에 따른 시간복잡도는 O(1)이다

# 해시 테이블의 주요 연산과 시간 복잡도는 다음과 같다
# 딕셔너리의 주요 연산 시간 복잡도
# 연산 - 시간 복잡도 : 설명
# len(a) - O(1) : 요소의 개수를 리턴
# a[key] - O(1) : 키를 조회하여 값을 리턴
# a[key] = value - O(1) : key/value를 삽입
# key in a - O(1) : 딕셔너리에 키가 존재하는지 확인

# 이처럼 딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 매우 우수한 자료형
# key/value 구조의 데이터를 저장하는 유용한 자료형으로서
# 코딩 테스트에서 리스트만큼이나 매우 빈번하게 활용
# 원래 파이썬에서 딕셔너리는 입력 순서가 유지되지 않았다
# 마찬가지로 대부분의 언어에서 해시 테이블을 이용한 자료형은 
# 입력 순서가 유지되지 않는다
# 파이썬도 3.6 이하에서는 입력 순서가 유지되지 않아
# collections.OrderDict()라는 별도의 자료형을 제공했다
# 그러나 파이썬 3.7부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선되었다
# 다만, 여전히 3.6 이하 버전 사용하는 곳이 많고 하위버전과의 호환성,
# 코딩테스트 시에도 인터프리터의 버전을 정확히 확인할 수 없는 상황에서 
# 입력 순서가 유지되지 않을 수도 있으므로, 딕셔너리의 입력 순서가 유지될 것이라고 가정하고 진행하는 것은 위험
# 이외에도 파이썬 3.6 부터는 딕셔너리의 메모리 사용량이 20% 정도 줄어드는 성능 개선 또한 진행되었다

# 이러한 개선 외에도 파이썬에서는 딕셔너리를 효율적으로 생성하기 위한 추가 모듈을 많이 지원함
# 파이썬 3.6 이하에서 항상 입력 순서가 유지되는 collections.OrderDict()를 비롯해
# 조회 시 항상 디폴트 값을 생성해 키 오류를 방지하는 coeections.defaultdict()
# 요소의 값을 키로 하고 개수를 값 형태로 만들어 카우팅하는 collections.Counter() 등이 있다
# collections 모듈에서 지원하는 기능들은 앞으로 코딩테스트 문제를 풀이하는 데에 매우 유용하게 활용됨

# 딕셔너리의 활용 방법
# 딕셔너리 선언
a = dict()
print(type(a)) # <class 'dict'>
a = {}
print(type(a)) # <class 'dict'>

# 다음과 같이 key1, key2는 초기값으로 지정해 선언하거나 
# key3 처럼 나중에 별도로 선언하여 value3이라는 값을 할당할 수 있다

a = {'key1' : 'value1', 'key2' : 'value2'}
print(a) # {'key1': 'value1', 'key2': 'value2'}

a['key3'] = 'value3'
print(a) # {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}

# 딕셔너리의 키를 지정하면 값을 조회할 수 있다
# 다음과 같이 존재하지 않는 키를 조회할 경우에는 에러가 발생한다
print(a['key1']) # value1

# a['key4'] # KeyError: 'key4'

# 리스트에서는 존재하지 않는 index를 조회할 경우 IndexError 가 발생,
# 딕셔너리에서는 이처럼 존재하지 않는 키 key4를 조회하면 KeyError 가 발생
# try구문으로 예외 처리 가능

try: 
    print(a['key4'])
except KeyError:
    print('존재하지 않는 키') # 존재하지 않는 키 

# 이처럼 존재하지 않는 키가 있을 경우 예외 처리를 하게 되면
# 나중에 삽입하는 등 별도로 추가 작업을 할 수가 있어 유용
# Key Error는 키를 삭제할 때도 발생한다

# del a['key4'] # KeyError: 'key4'

# 마찬가지로 try 구문으로 예외 처리를 하게 되면
# 존재하지 않는 키의 경우 별도 작업을 할 수 있어 유용
# 예외 처리를 하는 방법 외에도 다음과 같이 키가 존재하는지 미리 확인해 이후 작업을 진행할 수도 있다
print('key4' in a) # False

if 'key4' in a :
    print("존재하는 키")
else:
    print("존재하지 않는 키")

# 존재하지 않는 키

# 딕셔너리에 있는 key/value는 for 반복문으로도 조회 가능
# 딕셔너리의 items() method를 사용하면 키와 값을 각각 꺼내올 수 있다

for k, v in a.items():
    print(k, v)

'''
key1 value1
key2 value2
key3 value3
'''
# 딕셔너리의 키는 del로 삭제
del a ['key1']
print(a) # {'key2': 'value2', 'key3': 'value3'}


# 딕셔너리 모듈
# 딕셔너리와 관련된 특수한 형태의 컨테이너 자료형인 defaultdict,Counter,OrderedDict

# defaultdict 객체
# defaultdict 객체는 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신
# 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다
# 마찬가지로 실제로는 coeections.defaultdict 클래스를 갖는다

import collections
b = collections.defaultdict(int)
# b = {}
b['A'] = 5
b['B'] = 4
print(b) # defaultdict(<class 'int'>, {'A': 5, 'B': 4})

# 여기서 A와 B에 각각 5와 4를 할당함
# 이 딕셔너리에는 이렇게 2개의 아이템이 존재

b['C'] += 1
print(b) # defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C': 1})
# C는 존재하지 않는 키였음
# 원래 딕셔너리라면 KeyError가 발생했을 것
'''
323번 줄, b = {}로 defaultdict가 아닌 일반 dict 선언했을 시 나타나는 오류
{'A': 5, 'B': 4}
Traceback (most recent call last):
  File "d:\leetcode\tutorials\chapter_5.py", line 331, in <module>
    b['C'] += 1
KeyError: 'C'
'''
# 그러나 defaultdict 객체는 에러 없이 바로 +1 이 연산이 가능
# 이 경우 디폴트인 0을 기준으로 자동으로 생성한 후 여기에 1을 더해
# 최종적으로 1이 만들어진다
# 결과를 보면 3개의 아이템이 존재하는 것을 확인할 수 있다


# Counter 객체
# Counter 객체는 아이템에 대한 개수를 계산해 딕셔너리로 리터너하며 다음과 같이 사용된다

a = [1, 2, 3, 4, 5, 5, 5, 6, 6]
b = collections.Counter(a)
print(b) # Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})

# Counter 객체는 이처럼 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성
# 실제로는 다음과 같이 딕셔너리를 한 번 더 래핑 wrapping한 collections.Counter 클래스를 갖는다
print(type(b)) # <class 'collections.Counter'>

# 개수를 자동으로 계산해주므로 매우 편리
# 여러 분야에서 다양하게 활용
# COunter 객체에서 가장 빈도 수가 높은 요소는 어떻게 추출?
# most_common()을 사용하면 된다
print(b.most_common(2)) # [(5, 3), (6, 2)]
# 이처럼 가장 빈도가 높은 2개의 요소가 추출이 된다


# OrderedDict 객체
# 대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다
# 파이썬도 3.6 이하에서는 마찬가지였고 입력 순서가 유지되는 OrderedDict라는 별도의 객체를 제공했다
# 다음과 같이 입력값을 부여할 경우 OrderedDict 는 입력 그대로 순서가 유지된다

c = collections.OrderedDict({'banana':3, 'apple':4, 'pear':1, 'orange':2})
print(c) # OrderedDict([('banana', 3), ('apple', 4), ('pear', 1), ('orange', 2)])


# 그러나 파이썬 3.7부터 딕셔너리는 내부적으로 인덱스를 사용하여 입력 순서가 유지되도록 개선됨
# 따라서 더 이상 OrderedDict 사용할 필요 X
# 기본 딕셔너리만 사용해도 입력 순서 충분히 유지
# OrderedDict는 순서와 관련된 몇 가지 추가 메소드를 제공한다는 점 이외에는 사실 하위호환성을 위해 남겨짐
# 그러나 코딩 테스트 시 하위 버전의 파이썬 인터프리터를 사용하는 경우가 있고
# 원래 해시 테이블은 입력 순서에 관여하지 않는 자료형인 만큼,
# 무턱대고 딕셔너리로 입력 순서를 기대하는 것은 위험



# 문법 : 타입 선언
# 파이썬에서 타입을 선언하는 문법은 타입의 이름을 지정하는 방법이 있지만
# 기호를 사용해서 좀 더 간편하게 처리할 수도 있다
# 먼저 이름을 선언하는 방식
a = list()
print(type(a))
# <class 'list'>

# 기호로는 어떻게 선언?
print(type([])) # <class 'list'>
print(type(())) # <class 'tuple'>
print(type({})) # <class 'dict'>
print(type({1})) # <class 'set'>

# dictionary와 set 집합은 같은 중괄호를 사용
# but, 키의 존재 유무로 서로 다른 자료형으로 선언된다
# key 없이 값만 1로 선언할 경우 집합 자료형이 된다!
